#pragma once

/**
 * @file core/analyzer.hpp
 * @author zuudevs (zuudevs@domain.com)
 * @brief 
 * @version 1.0
 * @date 2025-12-05
 * 
 * @copyright Copyright (c) 2025
 * 
 */

#include <string>
#include <unordered_map>
#include <chrono>
#include "util/ts_queue.hpp"

/**
 * @brief Enum representing the type of action to be taken based on analysis.
 */
enum class ActionType : uint8_t {
    BLOCK_IP,       ///< Block the source IP address.
    LOG_SUSPICIOUS, ///< Log the event as suspicious activity.
    UNBLOCK_IP      ///< Unblock a previously blocked IP.
};

/**
 * @brief Structure representing an actionable event generated by the analyzer.
 */
struct ActionEvent {
    ActionType type;        ///< The type of action to perform.
    std::string ip_address; ///< The target IP address associated with the event.
    std::string reason;     ///< A description or reason for the action.
};

/**
 * @brief Analyzes network packets for suspicious activity.
 * 
 * This class consumes raw packets from a queue, performs checks (like port scan detection
 * or Modbus analysis), and produces ActionEvents.
 */
class PacketAnalyzer {
    ThreadSafeQueue<std::vector<uint8_t>>& packet_queue_;
    ThreadSafeQueue<ActionEvent>& action_queue_;
    std::atomic<bool> running_{false};
    
    // Port scan detection
    struct ScanTracker {
        std::unordered_map<uint16_t, int> port_attempts;
        std::chrono::steady_clock::time_point last_seen;
    };
    std::unordered_map<std::string, ScanTracker> scan_map_;
    std::mutex scan_mutex_;

public:
    /**
     * @brief Construct a new Packet Analyzer object.
     * 
     * @param pkt_q Reference to the queue containing raw packets.
     * @param act_q Reference to the queue where action events will be pushed.
     */
    PacketAnalyzer(ThreadSafeQueue<std::vector<uint8_t>>& pkt_q,
                   ThreadSafeQueue<ActionEvent>& act_q);
    
    /**
     * @brief Starts the analysis process.
     */
    void start();

    /**
     * @brief Stops the analysis process.
     */
    void stop();

    /**
     * @brief The main analysis loop.
     * 
     * Continuously processes packets from the input queue.
     */
    void run();

private:
    /**
     * @brief Gets the offset of the IP header based on the platform.
     * 
     * @return constexpr size_t The byte offset (0 for Windows raw sockets, 14 for Linux cooked sockets).
     */
    static constexpr size_t get_ip_offset() {
#ifdef _WIN32
        return 0;  // Windows: starts at IP header
#else
        return 14; // Linux: skip Ethernet header
#endif
    }
    
    /**
     * @brief Analyzes a single packet.
     * 
     * @param packet The raw packet data.
     */
    void analyze_packet(const std::vector<uint8_t>& packet);

    /**
     * @brief Extracts the source IP address from a packet.
     * 
     * @param packet The raw packet data.
     * @return std::string The source IP in dotted-decimal notation.
     */
    std::string extract_src_ip(const std::vector<uint8_t>& packet);

    /**
     * @brief Extracts the destination port from a packet.
     * 
     * @param packet The raw packet data.
     * @return uint16_t The destination port (host byte order).
     */
    uint16_t extract_dst_port(const std::vector<uint8_t>& packet);

    /**
     * @brief Checks if the packet is a TCP SYN packet.
     * 
     * @param packet The raw packet data.
     * @return true If the SYN flag is set.
     * @return false Otherwise.
     */
    bool is_syn_packet(const std::vector<uint8_t>& packet);

    /**
     * @brief Checks for specific Modbus function codes (e.g., Write Coil).
     * 
     * @param packet The raw packet data.
     */
    void check_modbus_write(const std::vector<uint8_t>& packet);

    /**
     * @brief Updates port scan tracking logic for a specific source IP.
     * 
     * @param src_ip The source IP address.
     * @param dst_port The destination port attempted.
     */
    void check_port_scan(const std::string& src_ip, uint16_t dst_port);
};